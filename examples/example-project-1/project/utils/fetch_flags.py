# This file was generated by Xen ProjGen.
# File: fetch_flags.py
# Version: 1.0
# Author: XeniaPhe
# License: MIT License
# Github: https://github.com/XeniaPhe/Xen-ProjGen
# Description: Parses the compiler_flags.yaml file and retrieves the flags for CMake

import re
import sys

if len(sys.argv) != 3:
    print("Usage: script.py <compiler> <build_type>", file = sys.stderr)
    sys.exit(1)

target_compiler = sys.argv[1].lower()
target_build_type = sys.argv[2].lower()

file_content = ""
try:
    with open("../config/compiler_flags.yaml", 'r') as file:
        file_content = file.read()
except FileNotFoundError:
    print("The file compiler_flags.yaml not found!")
except IOError as e:
    print(f"An I/O error occurred while accessing compiler_flags.yaml:\n {e}")
except Exception as e:
    print(f"An unexpected error occurred:\n {e}")

flags = []
current_compiler = None
current_build_type = None
current_flag = None

# Regex patterns to identify sections and flag details
compiler_pattern = re.compile(r'^\s*(gcc|clang|msvc):', re.IGNORECASE)
build_type_pattern = re.compile(r'^\s*(debug|release|minsizerel|relwithdebinfo):', re.IGNORECASE)
flag_pattern = re.compile(r'^\s*- flag: "(.*)"')
enabled_pattern = re.compile(r'^\s*enabled: (true|false)')

lines = file_content.splitlines()

for line in lines:
    # Skip comments or empty lines
    if not line.strip() or line.strip().startswith('#'):
        continue
    
    # Detect the compiler section (gcc, clang, msvc)
    compiler_match = compiler_pattern.match(line)
    if compiler_match:
        # Break out if all the requested data has been processed
        if current_compiler == target_compiler:
            break

        current_compiler = compiler_match.group(1).lower()
        continue

    if current_compiler != target_compiler:
        continue
    
    # Detect the build type (debug, release)
    build_type_match = build_type_pattern.match(line)
    if build_type_match:
        # Break out if all the requested data has been processed
        if current_build_type == target_build_type:
            break

        current_build_type = build_type_match.group(1).lower()
        continue

    if current_build_type != target_build_type:
        continue
    
    # Parse flags and enabled status
    if not current_flag:
        flag_match = flag_pattern.match(line)
        if flag_match:
            current_flag = flag_match.group(1)

        continue
    
    enabled_match = enabled_pattern.match(line)
    if enabled_match:
        if enabled_match.group(1).lower() == "true":
            flags.append(current_flag)

        current_flag = None

cmake_flags = ";".join(flags).strip()
print(cmake_flags)